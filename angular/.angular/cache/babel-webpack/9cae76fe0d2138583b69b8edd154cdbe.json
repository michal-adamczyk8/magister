{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, ElementRef, Renderer2, Input, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction NotifierContainerComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 2);\n    ɵngcc0.ɵɵelementStart(1, \"notifier-notification\", 3);\n    ɵngcc0.ɵɵlistener(\"ready\", function NotifierContainerComponent_li_1_Template_notifier_notification_ready_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ctx_r2.onNotificationReady($event);\n    })(\"dismiss\", function NotifierContainerComponent_li_1_Template_notifier_notification_dismiss_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.onNotificationDismiss($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const notification_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"notification\", notification_r1);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    notification: a0\n  };\n};\n\nfunction NotifierNotificationComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.notification.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx_r0.notification));\n  }\n}\n\nfunction NotifierNotificationComponent_ng_template_1_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 5);\n    ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_ng_template_1_button_2_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r4.onClickDismiss();\n    });\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(1, \"svg\", 6);\n    ɵngcc0.ɵɵelement(2, \"path\", 7);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction NotifierNotificationComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"p\", 3);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(2, NotifierNotificationComponent_ng_template_1_button_2_Template, 3, 0, \"button\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.notification.message);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.config.behaviour.showDismissButton);\n  }\n}\n\nclass NotifierNotification {\n  /**\n   * Constructor\n   *\n   * @param options Notifier options\n   */\n  constructor(options) {\n    /**\n     * The template to customize\n     * the appearance of the notification\n     */\n    this.template = null;\n    Object.assign(this, options); // If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n    // datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n    // is not possible due to the action queue concept.\n\n    if (options.id === undefined) {\n      this.id = `ID_${new Date().getTime()}`;\n    }\n  }\n\n}\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\n\n\nclass NotifierConfig {\n  /**\n   * Constructor\n   *\n   * @param [customOptions={}] Custom notifier options, optional\n   */\n  constructor(customOptions = {}) {\n    // Set default values\n    this.animations = {\n      enabled: true,\n      hide: {\n        easing: 'ease',\n        offset: 50,\n        preset: 'fade',\n        speed: 300\n      },\n      overlap: 150,\n      shift: {\n        easing: 'ease',\n        speed: 300\n      },\n      show: {\n        easing: 'ease',\n        preset: 'slide',\n        speed: 300\n      }\n    };\n    this.behaviour = {\n      autoHide: 7000,\n      onClick: false,\n      onMouseover: 'pauseAutoHide',\n      showDismissButton: true,\n      stacking: 4\n    };\n    this.position = {\n      horizontal: {\n        distance: 12,\n        position: 'left'\n      },\n      vertical: {\n        distance: 12,\n        gap: 10,\n        position: 'bottom'\n      }\n    };\n    this.theme = 'material'; // The following merges the custom options into the notifier config, respecting the already set default values\n    // This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n    // Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n\n    if (customOptions.theme !== undefined) {\n      this.theme = customOptions.theme;\n    }\n\n    if (customOptions.animations !== undefined) {\n      if (customOptions.animations.enabled !== undefined) {\n        this.animations.enabled = customOptions.animations.enabled;\n      }\n\n      if (customOptions.animations.overlap !== undefined) {\n        this.animations.overlap = customOptions.animations.overlap;\n      }\n\n      if (customOptions.animations.hide !== undefined) {\n        Object.assign(this.animations.hide, customOptions.animations.hide);\n      }\n\n      if (customOptions.animations.shift !== undefined) {\n        Object.assign(this.animations.shift, customOptions.animations.shift);\n      }\n\n      if (customOptions.animations.show !== undefined) {\n        Object.assign(this.animations.show, customOptions.animations.show);\n      }\n    }\n\n    if (customOptions.behaviour !== undefined) {\n      Object.assign(this.behaviour, customOptions.behaviour);\n    }\n\n    if (customOptions.position !== undefined) {\n      if (customOptions.position.horizontal !== undefined) {\n        Object.assign(this.position.horizontal, customOptions.position.horizontal);\n      }\n\n      if (customOptions.position.vertical !== undefined) {\n        Object.assign(this.position.vertical, customOptions.position.vertical);\n      }\n    }\n  }\n\n}\n/**\n * Injection Token for notifier options\n */\n\n\nconst NotifierOptionsToken = new InjectionToken('[angular-notifier] Notifier Options');\n/**\n * Injection Token for notifier configuration\n */\n\nconst NotifierConfigToken = new InjectionToken('[anuglar-notifier] Notifier Config');\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\n\nlet NotifierQueueService = /*#__PURE__*/(() => {\n  class NotifierQueueService {\n    /**\n     * Constructor\n     */\n    constructor() {\n      this.actionStream = new Subject();\n      this.actionQueue = [];\n      this.isActionInProgress = false;\n    }\n    /**\n     * Push a new action to the queue, and try to run it\n     *\n     * @param action Action object\n     */\n\n\n    push(action) {\n      this.actionQueue.push(action);\n      this.tryToRunNextAction();\n    }\n    /**\n     * Continue with the next action (called when the current action is finished)\n     */\n\n\n    continue() {\n      this.isActionInProgress = false;\n      this.tryToRunNextAction();\n    }\n    /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     */\n\n\n    tryToRunNextAction() {\n      if (this.isActionInProgress || this.actionQueue.length === 0) {\n        return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n      }\n\n      this.isActionInProgress = true;\n      this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n    }\n\n  }\n\n  NotifierQueueService.ɵfac = function NotifierQueueService_Factory(t) {\n    return new (t || NotifierQueueService)();\n  };\n\n  NotifierQueueService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NotifierQueueService,\n    factory: NotifierQueueService.ɵfac\n  });\n  return NotifierQueueService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\n\n\nlet NotifierService = /*#__PURE__*/(() => {\n  class NotifierService {\n    /**\n     * Constructor\n     *\n     * @param notifierQueueService Notifier queue service\n     * @param config               Notifier configuration, optionally injected as a dependency\n     */\n    constructor(notifierQueueService, config) {\n      this.queueService = notifierQueueService;\n      this.config = config;\n    }\n    /**\n     * Get the notifier configuration\n     *\n     * @returns Notifier configuration\n     */\n\n\n    getConfig() {\n      return this.config;\n    }\n    /**\n     * Get the observable for handling actions\n     *\n     * @returns Observable of NotifierAction\n     */\n\n\n    get actionStream() {\n      return this.queueService.actionStream.asObservable();\n    }\n    /**\n     * API: Show a new notification\n     *\n     * @param notificationOptions Notification options\n     */\n\n\n    show(notificationOptions) {\n      this.queueService.push({\n        payload: notificationOptions,\n        type: 'SHOW'\n      });\n    }\n    /**\n     * API: Hide a specific notification, given its ID\n     *\n     * @param notificationId ID of the notification to hide\n     */\n\n\n    hide(notificationId) {\n      this.queueService.push({\n        payload: notificationId,\n        type: 'HIDE'\n      });\n    }\n    /**\n     * API: Hide the newest notification\n     */\n\n\n    hideNewest() {\n      this.queueService.push({\n        type: 'HIDE_NEWEST'\n      });\n    }\n    /**\n     * API: Hide the oldest notification\n     */\n\n\n    hideOldest() {\n      this.queueService.push({\n        type: 'HIDE_OLDEST'\n      });\n    }\n    /**\n     * API: Hide all notifications at once\n     */\n\n\n    hideAll() {\n      this.queueService.push({\n        type: 'HIDE_ALL'\n      });\n    }\n    /**\n     * API: Shortcut for showing a new notification\n     *\n     * @param type             Type of the notification\n     * @param message          Message of the notification\n     * @param [notificationId] Unique ID for the notification (optional)\n     */\n\n\n    notify(type, message, notificationId) {\n      const notificationOptions = {\n        message,\n        type\n      };\n\n      if (notificationId !== undefined) {\n        notificationOptions.id = notificationId;\n      }\n\n      this.show(notificationOptions);\n    }\n\n  }\n\n  NotifierService.ɵfac = function NotifierService_Factory(t) {\n    return new (t || NotifierService)(ɵngcc0.ɵɵinject(NotifierQueueService), ɵngcc0.ɵɵinject(NotifierConfigToken));\n  };\n\n  NotifierService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NotifierService,\n    factory: NotifierService.ɵfac\n  });\n  return NotifierService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n\n\nlet NotifierContainerComponent = /*#__PURE__*/(() => {\n  class NotifierContainerComponent {\n    /**\n     * Constructor\n     *\n     * @param changeDetector       Change detector, used for manually triggering change detection runs\n     * @param notifierQueueService Notifier queue service\n     * @param notifierService      Notifier service\n     */\n    constructor(changeDetector, notifierQueueService, notifierService) {\n      this.changeDetector = changeDetector;\n      this.queueService = notifierQueueService;\n      this.config = notifierService.getConfig();\n      this.notifications = []; // Connects this component up to the action queue, then handle incoming actions\n\n      this.queueServiceSubscription = this.queueService.actionStream.subscribe(action => {\n        this.handleAction(action).then(() => {\n          this.queueService.continue();\n        });\n      });\n    }\n    /**\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\n     */\n\n\n    ngOnDestroy() {\n      if (this.queueServiceSubscription) {\n        this.queueServiceSubscription.unsubscribe();\n      }\n    }\n    /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param   index        Index\n     * @param   notification Notifier notification\n     * @returns Notification ID as the unique identnfier\n     */\n\n\n    identifyNotification(index, notification) {\n      return notification.id;\n    }\n    /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param notificationId ID of the notification to dismiss\n     */\n\n\n    onNotificationDismiss(notificationId) {\n      this.queueService.push({\n        payload: notificationId,\n        type: 'HIDE'\n      });\n    }\n    /**\n     * Event handler, handles notification ready events\n     *\n     * @param notificationComponent Notification component reference\n     */\n\n\n    onNotificationReady(notificationComponent) {\n      const currentNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n\n      currentNotification.component = notificationComponent; // Save the new omponent reference\n\n      this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n    }\n    /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n\n\n    handleAction(action) {\n      switch (action.type // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n      ) {\n        case 'SHOW':\n          return this.handleShowAction(action);\n\n        case 'HIDE':\n          return this.handleHideAction(action);\n\n        case 'HIDE_OLDEST':\n          return this.handleHideOldestAction(action);\n\n        case 'HIDE_NEWEST':\n          return this.handleHideNewestAction(action);\n\n        case 'HIDE_ALL':\n          return this.handleHideAllAction();\n\n        default:\n          return new Promise(resolve => {\n            resolve(); // Ignore unknown action types\n          });\n      }\n    }\n    /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n\n\n    handleShowAction(action) {\n      return new Promise(resolve => {\n        this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n\n        this.addNotificationToList(new NotifierNotification(action.payload));\n      });\n    }\n    /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @param notification New notification to show\n     */\n\n\n    continueHandleShowAction(notification) {\n      // First (which means only one) notification in the list?\n      const numberOfNotifications = this.notifications.length;\n\n      if (numberOfNotifications === 1) {\n        notification.component.show().then(this.tempPromiseResolver); // Done\n      } else {\n        const implicitStackingLimit = 2; // Stacking enabled? (stacking value below 2 means stacking is disabled)\n\n        if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n          this.notifications[0].component.hide().then(() => {\n            this.removeNotificationFromList(this.notifications[0]);\n            notification.component.show().then(this.tempPromiseResolver); // Done\n          });\n        } else {\n          const stepPromises = []; // Are there now too many notifications?\n\n          if (numberOfNotifications > this.config.behaviour.stacking) {\n            const oldNotifications = this.notifications.slice(1, numberOfNotifications - 1); // Are animations enabled?\n\n            if (this.config.animations.enabled) {\n              // Is animation overlap enabled?\n              if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                stepPromises.push(this.notifications[0].component.hide());\n                setTimeout(() => {\n                  stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                }, this.config.animations.hide.speed - this.config.animations.overlap);\n                setTimeout(() => {\n                  stepPromises.push(notification.component.show());\n                }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n              } else {\n                stepPromises.push(new Promise(resolve => {\n                  this.notifications[0].component.hide().then(() => {\n                    this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                      notification.component.show().then(resolve);\n                    });\n                  });\n                }));\n              }\n            } else {\n              stepPromises.push(this.notifications[0].component.hide());\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              stepPromises.push(notification.component.show());\n            }\n          } else {\n            const oldNotifications = this.notifications.slice(0, numberOfNotifications - 1); // Are animations enabled?\n\n            if (this.config.animations.enabled) {\n              // Is animation overlap enabled?\n              if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                setTimeout(() => {\n                  stepPromises.push(notification.component.show());\n                }, this.config.animations.shift.speed - this.config.animations.overlap);\n              } else {\n                stepPromises.push(new Promise(resolve => {\n                  this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                    notification.component.show().then(resolve);\n                  });\n                }));\n              }\n            } else {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              stepPromises.push(notification.component.show());\n            }\n          }\n\n          Promise.all(stepPromises).then(() => {\n            if (numberOfNotifications > this.config.behaviour.stacking) {\n              this.removeNotificationFromList(this.notifications[0]);\n            }\n\n            this.tempPromiseResolver();\n          }); // Done\n        }\n      }\n    }\n    /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @param   action Action object, payload contains the notification ID\n     * @returns Promise, resolved when done\n     */\n\n\n    handleHideAction(action) {\n      return new Promise(resolve => {\n        const stepPromises = []; // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n\n        const notification = this.findNotificationById(action.payload);\n\n        if (notification === undefined) {\n          resolve();\n          return;\n        } // Get older notifications\n\n\n        const notificationIndex = this.findNotificationIndexById(action.payload);\n\n        if (notificationIndex === undefined) {\n          resolve();\n          return;\n        }\n\n        const oldNotifications = this.notifications.slice(0, notificationIndex); // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n\n        if (oldNotifications.length > 0) {\n          // Are animations enabled?\n          if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(notification.component.hide());\n              setTimeout(() => {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n              }, this.config.animations.hide.speed - this.config.animations.overlap);\n            } else {\n              notification.component.hide().then(() => {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n              });\n            }\n          } else {\n            stepPromises.push(notification.component.hide());\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n          }\n        } else {\n          stepPromises.push(notification.component.hide());\n        } // Wait until both hiding and shifting is done, then remove the notification from the list\n\n\n        Promise.all(stepPromises).then(() => {\n          this.removeNotificationFromList(notification);\n          resolve(); // Done\n        });\n      });\n    }\n    /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n\n\n    handleHideOldestAction(action) {\n      // Are there any notifications? (prevent accidential errors)\n      if (this.notifications.length === 0) {\n        return new Promise(resolve => {\n          resolve();\n        }); // Done\n      } else {\n        action.payload = this.notifications[0].id;\n        return this.handleHideAction(action);\n      }\n    }\n    /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n\n\n    handleHideNewestAction(action) {\n      // Are there any notifications? (prevent accidential errors)\n      if (this.notifications.length === 0) {\n        return new Promise(resolve => {\n          resolve();\n        }); // Done\n      } else {\n        action.payload = this.notifications[this.notifications.length - 1].id;\n        return this.handleHideAction(action);\n      }\n    }\n    /**\n     * Hide all notifications at once\n     *\n     * @returns Promise, resolved when done\n     */\n\n\n    handleHideAllAction() {\n      return new Promise(resolve => {\n        // Are there any notifications? (prevent accidential errors)\n        const numberOfNotifications = this.notifications.length;\n\n        if (numberOfNotifications === 0) {\n          resolve(); // Done\n\n          return;\n        } // Are animations enabled?\n\n\n        if (this.config.animations.enabled && this.config.animations.hide.speed > 0 && this.config.animations.hide.offset !== false && this.config.animations.hide.offset > 0) {\n          for (let i = numberOfNotifications - 1; i >= 0; i--) {\n            const animationOffset = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n            setTimeout(() => {\n              this.notifications[i].component.hide().then(() => {\n                // Are we done here, was this the last notification to be hidden?\n                if (this.config.position.vertical.position === 'top' && i === 0 || this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1) {\n                  this.removeAllNotificationsFromList();\n                  resolve(); // Done\n                }\n              });\n            }, this.config.animations.hide.offset * animationOffset);\n          }\n        } else {\n          const stepPromises = [];\n\n          for (let i = numberOfNotifications - 1; i >= 0; i--) {\n            stepPromises.push(this.notifications[i].component.hide());\n          }\n\n          Promise.all(stepPromises).then(() => {\n            this.removeAllNotificationsFromList();\n            resolve(); // Done\n          });\n        }\n      });\n    }\n    /**\n     * Shift multiple notifications at once\n     *\n     * @param   notifications List containing the notifications to be shifted\n     * @param   distance      Distance to shift (in px)\n     * @param   toMakePlace   Flag, defining in which direciton to shift\n     * @returns Promise, resolved when done\n     */\n\n\n    shiftNotifications(notifications, distance, toMakePlace) {\n      return new Promise(resolve => {\n        // Are there any notifications to shift?\n        if (notifications.length === 0) {\n          resolve();\n          return;\n        }\n\n        const notificationPromises = [];\n\n        for (let i = notifications.length - 1; i >= 0; i--) {\n          notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n        }\n\n        Promise.all(notificationPromises).then(resolve); // Done\n      });\n    }\n    /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to add to the list of notifications\n     */\n\n\n    addNotificationToList(notification) {\n      this.notifications.push(notification);\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to be removed from the list of notifications\n     */\n\n\n    removeNotificationFromList(notification) {\n      this.notifications = this.notifications.filter(item => item.component !== notification.component);\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove all notifications from the list (triggers change detection)\n     */\n\n\n    removeAllNotificationsFromList() {\n      this.notifications = [];\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding notification\n     * @returns Notification, undefined if not found\n     */\n\n\n    findNotificationById(notificationId) {\n      return this.notifications.find(currentNotification => currentNotification.id === notificationId);\n    }\n    /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding a notification's index\n     * @returns Notification index, undefined if not found\n     */\n\n\n    findNotificationIndexById(notificationId) {\n      const notificationIndex = this.notifications.findIndex(currentNotification => currentNotification.id === notificationId);\n      return notificationIndex !== -1 ? notificationIndex : undefined;\n    }\n\n  }\n\n  NotifierContainerComponent.ɵfac = function NotifierContainerComponent_Factory(t) {\n    return new (t || NotifierContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NotifierQueueService), ɵngcc0.ɵɵdirectiveInject(NotifierService));\n  };\n\n  NotifierContainerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NotifierContainerComponent,\n    selectors: [[\"notifier-container\"]],\n    hostAttrs: [1, \"notifier__container\"],\n    decls: 2,\n    vars: 2,\n    consts: [[1, \"notifier__container-list\"], [\"class\", \"notifier__container-list-item\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"notifier__container-list-item\"], [3, \"notification\", \"ready\", \"dismiss\"]],\n    template: function NotifierContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0);\n        ɵngcc0.ɵɵtemplate(1, NotifierContainerComponent_li_1_Template, 2, 1, \"li\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.notifications)(\"ngForTrackBy\", ctx.identifyNotification);\n      }\n    },\n    directives: function () {\n      return [ɵngcc1.NgForOf, NotifierNotificationComponent];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NotifierContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst ɵ0 = () => {\n  return {\n    from: {\n      opacity: '1'\n    },\n    to: {\n      opacity: '0'\n    }\n  };\n},\n      ɵ1 = () => {\n  return {\n    from: {\n      opacity: '0'\n    },\n    to: {\n      opacity: '1'\n    }\n  };\n};\n/**\n * Fade animation preset\n */\n\n\nconst fade = {\n  hide: ɵ0,\n  show: ɵ1\n};\n\nconst ɵ0$1 = notification => {\n  // Prepare variables\n  const config = notification.component.getConfig();\n  const shift = notification.component.getShift();\n  let from;\n  let to; // Configure variables, depending on configuration and component\n\n  if (config.position.horizontal.position === 'left') {\n    from = {\n      transform: `translate3d( 0, ${shift}px, 0 )`\n    };\n    to = {\n      transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), ${shift}px, 0 )`\n    };\n  } else if (config.position.horizontal.position === 'right') {\n    from = {\n      transform: `translate3d( 0, ${shift}px, 0 )`\n    };\n    to = {\n      transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), ${shift}px, 0 )`\n    };\n  } else {\n    let horizontalPosition;\n\n    if (config.position.vertical.position === 'top') {\n      horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n    } else {\n      horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n    }\n\n    from = {\n      transform: `translate3d( -50%, ${shift}px, 0 )`\n    };\n    to = {\n      transform: `translate3d( -50%, ${horizontalPosition}, 0 )`\n    };\n  } // Done\n\n\n  return {\n    from,\n    to\n  };\n},\n      ɵ1$1 = notification => {\n  // Prepare variables\n  const config = notification.component.getConfig();\n  let from;\n  let to; // Configure variables, depending on configuration and component\n\n  if (config.position.horizontal.position === 'left') {\n    from = {\n      transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), 0, 0 )`\n    };\n    to = {\n      transform: 'translate3d( 0, 0, 0 )'\n    };\n  } else if (config.position.horizontal.position === 'right') {\n    from = {\n      transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), 0, 0 )`\n    };\n    to = {\n      transform: 'translate3d( 0, 0, 0 )'\n    };\n  } else {\n    let horizontalPosition;\n\n    if (config.position.vertical.position === 'top') {\n      horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n    } else {\n      horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n    }\n\n    from = {\n      transform: `translate3d( -50%, ${horizontalPosition}, 0 )`\n    };\n    to = {\n      transform: 'translate3d( -50%, 0, 0 )'\n    };\n  } // Done\n\n\n  return {\n    from,\n    to\n  };\n};\n/**\n * Slide animation preset\n */\n\n\nconst slide = {\n  hide: ɵ0$1,\n  show: ɵ1$1\n};\n/**\n * Notifier animation service\n */\n\nlet NotifierAnimationService = /*#__PURE__*/(() => {\n  class NotifierAnimationService {\n    /**\n     * Constructor\n     */\n    constructor() {\n      this.animationPresets = {\n        fade,\n        slide\n      };\n    }\n    /**\n     * Get animation data\n     *\n     * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n     * direction (either in or out) as well as the notifications (and its attributes) itself.\n     *\n     * @param   direction    Animation direction, either in or out\n     * @param   notification Notification the animation data should be generated for\n     * @returns Animation information\n     */\n\n\n    getAnimationData(direction, notification) {\n      // Get all necessary animation data\n      let keyframes;\n      let duration;\n      let easing;\n\n      if (direction === 'show') {\n        keyframes = this.animationPresets[notification.component.getConfig().animations.show.preset].show(notification);\n        duration = notification.component.getConfig().animations.show.speed;\n        easing = notification.component.getConfig().animations.show.easing;\n      } else {\n        keyframes = this.animationPresets[notification.component.getConfig().animations.hide.preset].hide(notification);\n        duration = notification.component.getConfig().animations.hide.speed;\n        easing = notification.component.getConfig().animations.hide.easing;\n      } // Build and return animation data\n\n\n      return {\n        keyframes: [keyframes.from, keyframes.to],\n        options: {\n          duration,\n          easing,\n          fill: 'forwards'\n        }\n      };\n    }\n\n  }\n\n  NotifierAnimationService.ɵfac = function NotifierAnimationService_Factory(t) {\n    return new (t || NotifierAnimationService)();\n  };\n\n  NotifierAnimationService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NotifierAnimationService,\n    factory: NotifierAnimationService.ɵfac\n  });\n  return NotifierAnimationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\n\n\nlet NotifierTimerService = /*#__PURE__*/(() => {\n  class NotifierTimerService {\n    /**\n     * Constructor\n     */\n    constructor() {\n      this.now = 0;\n      this.remaining = 0;\n    }\n    /**\n     * Start (or resume) the timer\n     *\n     * @param   duration Timer duration, in ms\n     * @returns          Promise, resolved once the timer finishes\n     */\n\n\n    start(duration) {\n      return new Promise(resolve => {\n        // For the first run ...\n        this.remaining = duration; // Setup, then start the timer\n\n        this.finishPromiseResolver = resolve;\n        this.continue();\n      });\n    }\n    /**\n     * Pause the timer\n     */\n\n\n    pause() {\n      clearTimeout(this.timerId);\n      this.remaining -= new Date().getTime() - this.now;\n    }\n    /**\n     * Continue the timer\n     */\n\n\n    continue() {\n      this.now = new Date().getTime();\n      this.timerId = window.setTimeout(() => {\n        this.finish();\n      }, this.remaining);\n    }\n    /**\n     * Stop the timer\n     */\n\n\n    stop() {\n      clearTimeout(this.timerId);\n      this.remaining = 0;\n    }\n    /**\n     * Finish up the timeout by resolving the timer promise\n     */\n\n\n    finish() {\n      this.finishPromiseResolver();\n    }\n\n  }\n\n  NotifierTimerService.ɵfac = function NotifierTimerService_Factory(t) {\n    return new (t || NotifierTimerService)();\n  };\n\n  NotifierTimerService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NotifierTimerService,\n    factory: NotifierTimerService.ɵfac\n  });\n  return NotifierTimerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\n\n\nlet NotifierNotificationComponent = /*#__PURE__*/(() => {\n  class NotifierNotificationComponent {\n    /**\n     * Constructor\n     *\n     * @param elementRef               Reference to the component's element\n     * @param renderer                 Angular renderer\n     * @param notifierService          Notifier service\n     * @param notifierTimerService     Notifier timer service\n     * @param notifierAnimationService Notifier animation service\n     */\n    constructor(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n      this.config = notifierService.getConfig();\n      this.ready = new EventEmitter();\n      this.dismiss = new EventEmitter();\n      this.timerService = notifierTimerService;\n      this.animationService = notifierAnimationService;\n      this.renderer = renderer;\n      this.element = elementRef.nativeElement;\n      this.elementShift = 0;\n    }\n    /**\n     * Component after view init lifecycle hook, setts up the component and then emits the ready event\n     */\n\n\n    ngAfterViewInit() {\n      this.setup();\n      this.elementHeight = this.element.offsetHeight;\n      this.elementWidth = this.element.offsetWidth;\n      this.ready.emit(this);\n    }\n    /**\n     * Get the notifier config\n     *\n     * @returns Notifier configuration\n     */\n\n\n    getConfig() {\n      return this.config;\n    }\n    /**\n     * Get notification element height (in px)\n     *\n     * @returns Notification element height (in px)\n     */\n\n\n    getHeight() {\n      return this.elementHeight;\n    }\n    /**\n     * Get notification element width (in px)\n     *\n     * @returns Notification element height (in px)\n     */\n\n\n    getWidth() {\n      return this.elementWidth;\n    }\n    /**\n     * Get notification shift offset (in px)\n     *\n     * @returns Notification element shift offset (in px)\n     */\n\n\n    getShift() {\n      return this.elementShift;\n    }\n    /**\n     * Show (animate in) this notification\n     *\n     * @returns Promise, resolved when done\n     */\n\n\n    show() {\n      return new Promise(resolve => {\n        // Are animations enabled?\n        if (this.config.animations.enabled && this.config.animations.show.speed > 0) {\n          // Get animation data\n          const animationData = this.animationService.getAnimationData('show', this.notification); // Set initial styles (styles before animation), prevents quick flicker when animation starts\n\n          const animatedProperties = Object.keys(animationData.keyframes[0]);\n\n          for (let i = animatedProperties.length - 1; i >= 0; i--) {\n            this.renderer.setStyle(this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n          } // Animate notification in\n\n\n          this.renderer.setStyle(this.element, 'visibility', 'visible');\n          const animation = this.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish = () => {\n            this.startAutoHideTimer();\n            resolve(); // Done\n          };\n        } else {\n          // Show notification\n          this.renderer.setStyle(this.element, 'visibility', 'visible');\n          this.startAutoHideTimer();\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Hide (animate out) this notification\n     *\n     * @returns Promise, resolved when done\n     */\n\n\n    hide() {\n      return new Promise(resolve => {\n        this.stopAutoHideTimer(); // Are animations enabled?\n\n        if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n          const animationData = this.animationService.getAnimationData('hide', this.notification);\n          const animation = this.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish = () => {\n            resolve(); // Done\n          };\n        } else {\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Shift (move) this notification\n     *\n     * @param   distance         Distance to shift (in px)\n     * @param   shiftToMakePlace Flag, defining in which direction to shift\n     * @returns Promise, resolved when done\n     */\n\n\n    shift(distance, shiftToMakePlace) {\n      return new Promise(resolve => {\n        // Calculate new position (position after the shift)\n        let newElementShift;\n\n        if (this.config.position.vertical.position === 'top' && shiftToMakePlace || this.config.position.vertical.position === 'bottom' && !shiftToMakePlace) {\n          newElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n        } else {\n          newElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n        }\n\n        const horizontalPosition = this.config.position.horizontal.position === 'middle' ? '-50%' : '0'; // Are animations enabled?\n\n        if (this.config.animations.enabled && this.config.animations.shift.speed > 0) {\n          const animationData = {\n            // TODO: Extract into animation service\n            keyframes: [{\n              transform: `translate3d( ${horizontalPosition}, ${this.elementShift}px, 0 )`\n            }, {\n              transform: `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`\n            }],\n            options: {\n              duration: this.config.animations.shift.speed,\n              easing: this.config.animations.shift.easing,\n              fill: 'forwards'\n            }\n          };\n          this.elementShift = newElementShift;\n          const animation = this.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish = () => {\n            resolve(); // Done\n          };\n        } else {\n          this.renderer.setStyle(this.element, 'transform', `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`);\n          this.elementShift = newElementShift;\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Handle click on dismiss button\n     */\n\n\n    onClickDismiss() {\n      this.dismiss.emit(this.notification.id);\n    }\n    /**\n     * Handle mouseover over notification area\n     */\n\n\n    onNotificationMouseover() {\n      if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n        this.pauseAutoHideTimer();\n      } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n        this.stopAutoHideTimer();\n      }\n    }\n    /**\n     * Handle mouseout from notification area\n     */\n\n\n    onNotificationMouseout() {\n      if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n        this.continueAutoHideTimer();\n      } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n        this.startAutoHideTimer();\n      }\n    }\n    /**\n     * Handle click on notification area\n     */\n\n\n    onNotificationClick() {\n      if (this.config.behaviour.onClick === 'hide') {\n        this.onClickDismiss();\n      }\n    }\n    /**\n     * Start the auto hide timer (if enabled)\n     */\n\n\n    startAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.start(this.config.behaviour.autoHide).then(() => {\n          this.onClickDismiss();\n        });\n      }\n    }\n    /**\n     * Pause the auto hide timer (if enabled)\n     */\n\n\n    pauseAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.pause();\n      }\n    }\n    /**\n     * Continue the auto hide timer (if enabled)\n     */\n\n\n    continueAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.continue();\n      }\n    }\n    /**\n     * Stop the auto hide timer (if enabled)\n     */\n\n\n    stopAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.stop();\n      }\n    }\n    /**\n     * Initial notification setup\n     */\n\n\n    setup() {\n      // Set start position (initially the exact same for every new notification)\n      if (this.config.position.horizontal.position === 'left') {\n        this.renderer.setStyle(this.element, 'left', `${this.config.position.horizontal.distance}px`);\n      } else if (this.config.position.horizontal.position === 'right') {\n        this.renderer.setStyle(this.element, 'right', `${this.config.position.horizontal.distance}px`);\n      } else {\n        this.renderer.setStyle(this.element, 'left', '50%'); // Let's get the GPU handle some work as well (#perfmatters)\n\n        this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n      }\n\n      if (this.config.position.vertical.position === 'top') {\n        this.renderer.setStyle(this.element, 'top', `${this.config.position.vertical.distance}px`);\n      } else {\n        this.renderer.setStyle(this.element, 'bottom', `${this.config.position.vertical.distance}px`);\n      } // Add classes (responsible for visual design)\n\n\n      this.renderer.addClass(this.element, `notifier__notification--${this.notification.type}`);\n      this.renderer.addClass(this.element, `notifier__notification--${this.config.theme}`);\n    }\n\n  }\n\n  NotifierNotificationComponent.ɵfac = function NotifierNotificationComponent_Factory(t) {\n    return new (t || NotifierNotificationComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NotifierService), ɵngcc0.ɵɵdirectiveInject(NotifierTimerService), ɵngcc0.ɵɵdirectiveInject(NotifierAnimationService));\n  };\n\n  NotifierNotificationComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NotifierNotificationComponent,\n    selectors: [[\"notifier-notification\"]],\n    hostAttrs: [1, \"notifier__notification\"],\n    hostBindings: function NotifierNotificationComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_click_HostBindingHandler() {\n          return ctx.onNotificationClick();\n        })(\"mouseout\", function NotifierNotificationComponent_mouseout_HostBindingHandler() {\n          return ctx.onNotificationMouseout();\n        })(\"mouseover\", function NotifierNotificationComponent_mouseover_HostBindingHandler() {\n          return ctx.onNotificationMouseover();\n        });\n      }\n    },\n    inputs: {\n      notification: \"notification\"\n    },\n    outputs: {\n      ready: \"ready\",\n      dismiss: \"dismiss\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([// We provide the timer to the component's local injector, so that every notification components gets its own\n    // instance of the timer service, thus running their timers independently from each other\n    NotifierTimerService])],\n    decls: 3,\n    vars: 2,\n    consts: [[3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\", \"ngIfElse\"], [\"predefinedNotification\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"notifier__notification-message\"], [\"class\", \"notifier__notification-button\", \"type\", \"button\", \"title\", \"dismiss\", 3, \"click\", 4, \"ngIf\"], [\"type\", \"button\", \"title\", \"dismiss\", 1, \"notifier__notification-button\", 3, \"click\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"20\", \"height\", \"20\", 1, \"notifier__notification-button-icon\"], [\"d\", \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"]],\n    template: function NotifierNotificationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, NotifierNotificationComponent_ng_container_0_Template, 1, 4, \"ng-container\", 0);\n        ɵngcc0.ɵɵtemplate(1, NotifierNotificationComponent_ng_template_1_Template, 3, 2, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = ɵngcc0.ɵɵreference(2);\n\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.notification.template)(\"ngIfElse\", _r1);\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NotifierNotificationComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param   options - Custom notifier options\n * @returns - Notifier configuration as result\n */\n\n\nfunction notifierCustomConfigFactory(options) {\n  return new NotifierConfig(options);\n}\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @returns - Notifier configuration as result\n */\n\n\nfunction notifierDefaultConfigFactory() {\n  return new NotifierConfig({});\n}\n/**\n * Notifier module\n */\n\n\nlet NotifierModule = /*#__PURE__*/(() => {\n  class NotifierModule {\n    /**\n     * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n     *\n     * @param   [options={}] - Custom notifier options\n     * @returns - Notifier module with custom providers\n     */\n    static withConfig(options = {}) {\n      return {\n        ngModule: NotifierModule,\n        providers: [// Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n        {\n          provide: NotifierOptionsToken,\n          useValue: options\n        }, // Provide a custom notifier configuration, based on the given notifier options\n        {\n          deps: [NotifierOptionsToken],\n          provide: NotifierConfigToken,\n          useFactory: notifierCustomConfigFactory\n        }]\n      };\n    }\n\n  }\n\n  NotifierModule.ɵfac = function NotifierModule_Factory(t) {\n    return new (t || NotifierModule)();\n  };\n\n  NotifierModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NotifierModule\n  });\n  NotifierModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [NotifierAnimationService, NotifierService, NotifierQueueService, // Provide the default notifier configuration if just the module is imported\n    {\n      provide: NotifierConfigToken,\n      useFactory: notifierDefaultConfigFactory\n    }],\n    imports: [[CommonModule]]\n  });\n  return NotifierModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NotifierModule, {\n    declarations: function () {\n      return [NotifierContainerComponent, NotifierNotificationComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [NotifierContainerComponent];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NotifierConfig, NotifierConfigToken, NotifierContainerComponent, NotifierModule, NotifierNotificationComponent, NotifierOptionsToken, NotifierService, notifierCustomConfigFactory, notifierDefaultConfigFactory, NotifierQueueService as ɵa, NotifierTimerService as ɵb, NotifierAnimationService as ɵc }; //# sourceMappingURL=angular-notifier.js.map","map":null,"metadata":{},"sourceType":"module"}